# Mesh Viewer

A lightweight Flask + vanilla JS webapp for visualizing the finite-element meshes
produced by `mesh_and_sources.py`. Use it to inspect connectivity, verify element
placement, and iterate on new material layouts before hooking in post-processing
layers like magnetization or current density heatmaps.

## Quick start

1. **Create/update a mesh case**
   ```bash
   cd ..  # repo root
   python mesh_and_sources.py
   ```
   This writes a compressed NPZ file under `cases/` (default:
   `cases/mag2d_case.npz`). Any NPZ written to that folder becomes selectable in
   the viewer.

2. **Install viewer dependencies**
   ```bash
   cd viewer
   python3 -m venv .venv
   source .venv/bin/activate
   pip install -r requirements.txt
   ```

3. **Launch the server**
   ```bash
   python app.py --debug
   ```
   Open the printed URL (default `http://127.0.0.1:5000`). Use the sidebar to pick
   a case and interact with the canvas (scroll to zoom, drag to pan).

## Features

- Reads any NPZ generated by `mesh_and_sources.py` (nodes, tris, region info, and
  field arrays).
- Renders mesh edges with a 1:1 aspect ratio so geometry is never stretched.
- Canvas pan/zoom with pointer + scroll, plus fit-to-view on load.
- Sidebar summaries of domain size, node/element counts, and quick statistics for
  `mu_r`, `|M|`, and `Jz`.
- Layer toggles: color-coded material regions (with copper wire highlight), live
  magnetization vectors, and a J<sub>free</sub> heatmap overlay.
- API endpoints (`/api/cases`, `/api/mesh?case=...`) that other tools can reuse.
- Front-end rendering pipeline already aware of per-element fields so adding
  material coloring, magnetization overlays, or checkbox-controlled layers later
  is straightforward.

## Future extensions

- Apply color ramps per region/material or per-field (e.g., J_free, M, Î½).
- Toggleable overlays for sources or measurement probes.
- Display vector glyphs or contour isolines.
- Accept JSON directly for meshes from other generators.

The UI already exposes disabled checkboxes for these layers to make it obvious
where to slot-in the rendering logic when the data becomes available.
